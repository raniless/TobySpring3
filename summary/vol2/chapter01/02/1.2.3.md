## 1.2.3 빈 의존관계 설정 방법
- XML: \<property>, \<constructor-arg>
  + 프로퍼티는 수정자 메소드 사용, 생성자는 빈 클래스의 생성자를 이용
  + \<property>: 수정자 주입
    * 하나의 프로퍼티가 하나의 빈 또는 값을 DI 하는데 사용
    * ref 애트리뷰트를 사용하면 빈 이름을 이용해 주입할 빈을 찾는다.
      ```xml
      <bean ...>
        <property name="printer" ref="defaultPrinter" />
      </bean>
      
      <bean id="defaultPrinter" class="...">
      ```
    * value 애트리뷰트는 단순 값 또는 빈이 아닌 오브젝트를 주입할 때 사용한다.
      ```xml
      <property name="name" value="Spring" />
      <property name="age" value="30" />
      <property name="myClass" value="java.lang.String" />
      ```
    * value 애트리뷰트로 넣을 수 있는 값의 타입에는 제한이 없다.
  + \<constructor-arg>: 생성자 주입
    * 생성자를 통한 빈 또는 값의 주입에 사용
    * 생성자의 파라미터를 이용하기 때문에 한 번에 여러 개의 오브젝트를 주입할 수 있다.
    * 생성자 파라미터는 파라미터 순서나 타입을 명시하는 방법이 필요하다.
      ```java
      public class Hello {
        private String name;
        private Printer printer;

        public Hello(String name, Printer printer) {
          this.name = name;
          this.printer = printer;
        }
      }
      ```
      ```xml
        <bean id="hello" class="springbook.learningtest.spring.ioc.bean.Hello">
          <constructor-arg index="0" value="Spring" />
          <constructor-arg index="1" ref="printer" />
        </bean>
      ```
    * 파라미터에 중복되는 타입이 없다면 타입으로 구분해줄 수도 있다.
    ```xml
    <constructor-arg type="java.lang.String" value="Spring" />
    <constructor-arg type="springbook.learningtest.spring.ioc.bean.Printer" ref="printer" />      
    ```
    * 파라미터 이름을 사용할 수도 있다.
    ```xml
    <constructor-arg name="name" value="Spring" />
    <constructor-arg name="printer" ref="printer" />      
    ```

- XML: 자동와이어링
  + byName : 빈 이름 자동와이어링
    * 보통 빈의 이름은 클래스 이름이나 빈이 구현한 대표적인 인터페이스 이름을 따른다.
    * 프로퍼티 이름도 프로퍼티 타입의 이름을 사용한다.
      ```xml
      <bean id="hello" ...>
        <property name="printer" ref="printer" />
        <property name="name" value="Spring" />
      </bean>

      <bean id="printer" class="...StringPrinter" />
      ```
    * autowire 모드를 지정하면 \<property>를 생략할 수 있다.
      ```xml
      <bean id="hello" class="...Hello" autowired="byName">
        <!-- <property name="printer" ref="printer" /> 생략 -->
        <!-- 자동와이어링을 통해 컨테이너가 자동으로 추가해준다. -->
        <property name="name" value="Spring" />
      </bean>
      ```
    * 빈의 모든 프로퍼티에 대해 이름이 동일한 빈을 찾아서 연결해준다.
    * 프로퍼티와 이름이 같은 빈이 없는 경우는 무시한다.
    * 자동와이어링을 적용하면서 명시적인 프로퍼티 선언을 함께 사용할 수 있다.
    * 모든 빈에 적용할 것이라면 \<beans>의 디폴트 자동와이어링 옵션을 변경
      ```xml
      <beans default-autowire="byName">
        <bean>...</bean>
        ...
      </beans>
      ```
  + byType : 타입에 의한 자동와이어링
    * 프로퍼티의 타입과 각 빈의 타입을 비교해서 자동으로 연결해주는 방법
    * \<bean>에 autowire="byType", \<beans>에 default-autowire="byType" 으로 설정하여 사용
      ```xml
      <beans default-autowire="byType">
        <bean>...</bean>
        ...
      </beans>

      <bean id="hello" class="...Hello" autowire="byType">...</bean>
      <bean id="mainPrinter" class="...StringPrinter" />
      ```
    * 타입이 같은 빈이 두 개 이상 존재하는 경우에는 적용되지 못한다. (스프링이 어떤 빈을 사용해야 할지 결정할 수가 없기 때문)
    * 이름을 비교할때보다 느리다.
    * 빈의 모든 프로퍼티에 적용되고 프로퍼티 개수가 많아지면 자동와이어링 대상이 아님에도 한 번씩 모든 빈의 타입과 비교하는 작업이 일어나야 한다.
    * 생성자에 자동와이어링 적용하려면 autowire="constructor" 애트리뷰트를 이용하면 된다.
    * XML 안에서 자동와이어링을 사용하는 방식의 단점
      1. XML만 봐서는 빈 사이의 의존관계를 알기 힘들다.
      2. 이름을 이용한 자동와이어링은 오타로 빈 이름을 잘못 적어서 DI 되지 않고 넘어갈 위험도 있다.
      3. 타입에 의한 자동와이어링은 대입 가능한 타입이 두 개 이상이면 문제가 된다.
      4. 하나의 빈에 대해 한 가지 자동와이어링 방식밖에 지정할 수 없다는 것이 한계
      
- XML: 네임스페이스와 전용 태그
  + 전용 태그에 의해 자동으로 등록되는 빈이 \<bean>으로 선언되는 다른 빈의 프로퍼티에 DI 되거나 반대로 전용 태그의 빈이 다른 빈을 참조하기도 한다.
  + 전용 태그에 의해 만들어지는 빈에 id를 지정하고 다른 빈에서는 이를 ref로 참조하여 사용
    ```xml
    <oxm: jaxb2-marshaller id="unmarshaller" contextPath="..." />
    
    <bean id="sqlService" class="springbook.user.sqlservice.OxmSqlService">
      <property name="unmarshaller" ref="unmarshaller" />
      <property name="sqlRegistry" ref="sqlRegistry" />
    </bean>
    ```
  + 전용 태그에서 다른 빈을 참조하는 경우 어떤 애트리뷰트로 빈의 id를 지정할 수 있는지 분명히 알고 있어야 한다.
    ```xml
    <aop:config>
      <aop:advisor advice-ref="transactionAdvice" pointcut="bean(*Service)" />
    </aop:config>
    
    <bean id="transactionAdvice" ... >
    ```
  + id를 선언하지 않는 경우 파악이 어려우므로 가능한한 id를 명시적으로 선언하는 것이 바람직하다.
  
- 애노테이션: @Resource
  + \<property> 선언과 비슷하게 주입할 빈을 아이디로 지정하는 방법
  + 자바 클래스의 수정자 뿐만 아니라 필드에도 붙일 수 있다.
  + @Resource 애노테이션을 사용하면 수정자 메소드가 없어도 직접 내부 필드에 DI할 수가 있다.
  + 수정자 메소드
    * 가장 대표적인 DI 방법
    ```java
    public class Hello {
      private Printer printer;
      ...
      @Resource(name="printer")
      public void setPrinter(Printer printer) {
        this.printer = printer;
      }
    }
    ```
    * @Resource와 같은 애노테이션으로 된 의존관계 정보를 이용해 DI가 이뤄지게 하려면 다음 세가 방법 중 하나를 선택해야 한다.
      1. XML의 \<context:annotation-config />
         - @Resource와 같은 애노테이션 의존 관계 정보를 읽어서 메타정보를 추가해주는 기능을 가진 빈 후처리기를 등록해주는 전용 태그
      2. XML의 \<context:component-scan />
         - 빈 스캐닝을 통한 빈 등록 방법을 지정하는 것인데, 내부적으로 첫 번째 태그로 만들어지는 빈을 함께 등록해준다.
      3. AnnotationConfigApplicationContext 또는 AnnotationConfigWebApplicationContext
         - 빈 스캐너와 애노테이션 의존관계 정보를 읽는 후처리기를 내장한 애플리케이션 컨텍스트를 사용하는 것
    * 빈 스캐닝은 항상 애노테이션 의존관계 설정을 지원한다고 기억하면 된다.
  + 필드
    * @Resource는 필드에도 붙을 수 있다.
    ```java
    @Component
    public class Hello {
      @Resource(name="printer")
      private Printer printer;
    
      //setPrinter() 메소드 없음
    }
    ```
    * @Resource가 필드에 붙어 있을 때는 그에 대응되는 수정자가 없어도 상관없다.
    * 필드의 접근자가 public이 아니어도 상관없다.
    * 프로퍼티에 대한 수정자가 없다면 그만큼 코드는 간결해지겠지만 테스트처럼 컨테이너 밖에서 수동으로 DI를 할 경우 불편하다.   
      그래서 단위 테스트가 필요한 클래스라면 수정자 없는 필드 주입을 사용하는 것 별로 바람직하지 못하다.
    * 반면에 컨테이너를 이용한 통합 테스트를 주로 하는 DAO에서는 수정자 없이 필드 주입만을 사용해도 별문제가 되지 않는다.
    * 참조하는 빈의 이름을 생략할 수도 있다.
      ```java
      @Resource
      private Printer printer;
      ```
    * name 엘리먼트를 생략하면 DI할 빈의 이름이 프로퍼티나 필드 이름과 같다고 가정한다.
    * 만약 @Resource에 name 엘리먼트를 지정하지 않았고 디폴트 이름으로는 참조할 빈을 찾을 수 없는 경우에는 타입을 이용해서 다시 찾음

- 애노테이션: @Autowired/@Inject
  + 기본적으로 타입에 의한 자동와이어링 방식으로 동작. 의미나 사용법은 거의 동일하다.
  + @Autowired
    * 스프링 2.5부터 적용된 스프링 전용 애노테이션
    * XML의 타입에 의한 자동와이어링 방식을 생성자, 필드, 수정자 메소드, 일반 메소드의 네가지로 확장한 것이다.
    * 수정자 메소드와 필드
      - @Resource 사용 방법과 비슷하다. 다른점은 이름 대신 필드나 프로퍼티 타입을 이용해 후보 빈을 찾는다는 것
      ```java
      //필드 주입
      public class Hello {
        @Autowired
        private Printer printer;
      }
      
      //수정자 메소드 주입
      public class Hello {
        private Printer printer;
      
        @Autowired
        public void setPrinter(Printer printer) {
          this.printer = printer;
        }
      }      
      ```
    * 생성자
      - @Autowired는 @Resource와 다르게 생성자에도 부여할 수 있다.
      ```java
      public class BaseSqlService implements SqlService {
        protected SqlReader sqlReader;
        protected SqlRegistry sqlRegistry;
      
        @Autowired
        public BaseSqlService(SqlReader sqlReader, SqlRegistry sqlRegistry) {
          this.sqlReader = sqlReader;
          this.sqlRegistry = sqlRegistry;
        }
      }
      ```
      - @Autowired는 단 하나의 생성자에만 사용할 수 있다는 제한이 있다.
    * 일반 메소드
      - 일반 메소드에도 적용할 수 있다. (애노테이션 방식의 고유한 기능)
      - 오브젝트 생성 후에 차례로 호출이 가능하므로 여러 개 만들어도 된다.
      - 단 이렇게 만들어진 클래스는 XML을 통해서는 의존관계를 설정할 방법이 없다는 점을 주의해야 한다.
      ```java
      public class BaseSqlService implements SqlService {
        protected SqlReader sqlReader;
        protected SqlRegistry sqlRegistry;
      
        @Autowired
        public void config(SqlReader sqlReader, SqlRegistry sqlRegistry) {
          this.sqlReader = sqlReader;
          this.sqlRegistry = sqlRegistry;
        }
      }
      ```
      - 동일한 타입을 가진 빈이 하나 이상 존재할 때 @Autowired를 사용하는 방법
        1. 컬렉션과 배열
        2. @Qualifier

  + @Inject
    * JavaEE 6 표준 스펙인 JSR-330에 정의되어 있는것으로, 스프링 외에도 JavaEE 6 스펙을 따르는 여타 프레임워크에서도 동일한 의미로 사용되는 DI를 위한 애노테이션
    * 스프링으로 개발한 POJO를 앞으로 다른 환경에서도 사용할 가능성이 있다면 @Inject와 DIJ(Dependency Injection for Java)에서 정의한 애노테이션을 사용하는게 좋다.
  
- @Autowired와 getBean(), 스프링 테스트
- 자바 코드에 의한 의존관계 설정
- 빈 의존관계 설정 전략